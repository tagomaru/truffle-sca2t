
<html>
    <head>
        <title>Mocha</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <style type="text/css">
        @charset "utf-8";

body {
  margin:0;
}

#mocha {
  font: 20px/1.5 "Helvetica Neue", Helvetica, Arial, sans-serif;
  margin: 60px 50px;
}

#mocha ul,
#mocha li {
  margin: 0;
  padding: 0;
}

#mocha ul {
  list-style: none;
}

#mocha h1,
#mocha h2 {
  margin: 0;
}

#mocha h1 {
  margin-top: 15px;
  font-size: 1em;
  font-weight: 200;
}

#mocha h1 a {
  text-decoration: none;
  color: inherit;
}

#mocha h1 a:hover {
  text-decoration: underline;
}

#mocha .suite .suite h1 {
  margin-top: 0;
  font-size: .8em;
}

#mocha .hidden {
  display: none;
}

#mocha h2 {
  font-size: 12px;
  font-weight: normal;
  cursor: pointer;
}

#mocha .suite {
  margin-left: 15px;
}

#mocha .test {
  margin-left: 15px;
  overflow: hidden;
}

#mocha .test.pending:hover h2::after {
  content: '(pending)';
  font-family: arial, sans-serif;
}

#mocha .test.pass.medium .duration {
  background: #c09853;
}

#mocha .test.pass.slow .duration {
  background: #b94a48;
}

#mocha .test.pass::before {
  content: '✓';
  font-size: 12px;
  display: block;
  float: left;
  margin-right: 5px;
  color: #00d6b2;
}

#mocha .test.pass .duration {
  font-size: 9px;
  margin-left: 5px;
  padding: 2px 5px;
  color: #fff;
  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);
  -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);
  box-shadow: inset 0 1px 1px rgba(0,0,0,.2);
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  -ms-border-radius: 5px;
  -o-border-radius: 5px;
  border-radius: 5px;
}

#mocha .test.pass.fast .duration {
  display: none;
}

#mocha .test.pending {
  color: #0b97c4;
}

#mocha .test.pending::before {
  content: '◦';
  color: #0b97c4;
}

#mocha .test.fail {
  color: #c00;
}

#mocha .test.fail pre {
  color: black;
}

#mocha .test.fail::before {
  content: '✖';
  font-size: 12px;
  display: block;
  float: left;
  margin-right: 5px;
  color: #c00;
}

#mocha .test pre.error {
  color: #c00;
  max-height: 300px;
  overflow: auto;
}

#mocha .test .html-error {
  overflow: auto;
  color: black;
  line-height: 1.5;
  display: block;
  float: left;
  clear: left;
  font: 12px/1.5 monaco, monospace;
  margin: 5px;
  padding: 15px;
  border: 1px solid #eee;
  max-width: 85%; /*(1)*/
  max-width: -webkit-calc(100% - 42px);
  max-width: -moz-calc(100% - 42px);
  max-width: calc(100% - 42px); /*(2)*/
  max-height: 300px;
  word-wrap: break-word;
  border-bottom-color: #ddd;
  -webkit-box-shadow: 0 1px 3px #eee;
  -moz-box-shadow: 0 1px 3px #eee;
  box-shadow: 0 1px 3px #eee;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
}

#mocha .test .html-error pre.error {
  border: none;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-box-shadow: 0;
  -moz-box-shadow: 0;
  box-shadow: 0;
  padding: 0;
  margin: 0;
  margin-top: 18px;
  max-height: none;
}

/**
 * (1): approximate for browsers not supporting calc
 * (2): 42 = 2*15 + 2*10 + 2*1 (padding + margin + border)
 *      ^^ seriously
 */
#mocha .test pre {
  display: block;
  float: left;
  clear: left;
  font: 12px/1.5 monaco, monospace;
  margin: 5px;
  padding: 15px;
  border: 1px solid #eee;
  max-width: 85%; /*(1)*/
  max-width: -webkit-calc(100% - 42px);
  max-width: -moz-calc(100% - 42px);
  max-width: calc(100% - 42px); /*(2)*/
  word-wrap: break-word;
  border-bottom-color: #ddd;
  -webkit-box-shadow: 0 1px 3px #eee;
  -moz-box-shadow: 0 1px 3px #eee;
  box-shadow: 0 1px 3px #eee;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
}

#mocha .test h2 {
  position: relative;
}

#mocha .test a.replay {
  position: absolute;
  top: 3px;
  right: 0;
  text-decoration: none;
  vertical-align: middle;
  display: block;
  width: 15px;
  height: 15px;
  line-height: 15px;
  text-align: center;
  background: #eee;
  font-size: 15px;
  -webkit-border-radius: 15px;
  -moz-border-radius: 15px;
  border-radius: 15px;
  -webkit-transition:opacity 200ms;
  -moz-transition:opacity 200ms;
  -o-transition:opacity 200ms;
  transition: opacity 200ms;
  opacity: 0.3;
  color: #888;
}

#mocha .test:hover a.replay {
  opacity: 1;
}

#mocha-report.pass .test.fail {
  display: none;
}

#mocha-report.fail .test.pass {
  display: none;
}

#mocha-report.pending .test.pass,
#mocha-report.pending .test.fail {
  display: none;
}
#mocha-report.pending .test.pass.pending {
  display: block;
}

#mocha-error {
  color: #c00;
  font-size: 1.5em;
  font-weight: 100;
  letter-spacing: 1px;
}

#mocha-stats {
  position: fixed;
  top: 15px;
  right: 10px;
  font-size: 12px;
  margin: 0;
  color: #888;
  z-index: 1;
}

#mocha-stats .progress {
  float: right;
  padding-top: 0;

  /**
   * Set safe initial values, so mochas .progress does not inherit these
   * properties from Bootstrap .progress (which causes .progress height to
   * equal line height set in Bootstrap).
   */
  height: auto;
  -webkit-box-shadow: none;
  -moz-box-shadow: none;
  box-shadow: none;
  background-color: initial;
}

#mocha-stats em {
  color: black;
}

#mocha-stats a {
  text-decoration: none;
  color: inherit;
}

#mocha-stats a:hover {
  border-bottom: 1px solid #eee;
}

#mocha-stats li {
  display: inline-block;
  margin: 0 5px;
  list-style: none;
  padding-top: 11px;
}

#mocha-stats canvas {
  width: 40px;
  height: 40px;
}

#mocha code .comment { color: #ddd; }
#mocha code .init { color: #2f6fad; }
#mocha code .string { color: #5890ad; }
#mocha code .keyword { color: #8a6343; }
#mocha code .number { color: #2f6fad; }

@media screen and (max-device-width: 480px) {
  #mocha {
    margin: 60px 0px;
  }

  #mocha #stats {
    position: absolute;
  }
}
#mocha .test.pass pre {
    display: none;
}

#mocha .test.fail pre {
    display: none;
}

#mocha .test pre.error {
    display: block;
}

#mocha .test .html-error pre.error {
    box-shadow: none;
}

#mocha .test:hover h2:after {
    color: #888888;
    content: "(view source)";
    font-family: arial;
    font-size: 12px;
    position: relative;
    right: -10px;
    top: 0;
}

#mocha .test.pass.pending h2 {
    cursor: auto;
}

#mocha .mocha-header {
    right: 30px;
    position: fixed;
    top: 15px;
    font-size: 14px;
    margin: 0;
    color: #888;
    z-index: 1;
}

#mocha .mocha-header em {
    font-style: normal;
    color: black;
}

#mocha .mocha-header ul {
    display: inline-block;
}

#mocha .mocha-stats li {
    display: inline-block;
    margin: 0 5px;
    list-style: none;
    padding-top: 11px;
}

#mocha .mocha-menu {
    margin-right: 10px;
}

#mocha .mocha-menu li {
    display: inline-block;
    margin-left: 10px;
    list-style: none;
}

#mocha .mocha-menu li span {
    display: inline-block;
    cursor: pointer;
    color: #fff;
    font-size: 14px;
    padding: 3px 7px 2px;
    box-shadow: 1px 1px 3px rgba(0,0,0,.2);
    border-radius: 5px;
    user-select: none;
}

#mocha .mocha-menu li span.checked {
    box-shadow: inset 1px 1px 3px rgba(0,0,0,.2);
}

#mocha .toggle-passes {
    background: #b94a48;
}

        </style>
    </head>
    <body>
        <div id="mocha">
            <div class="mocha-header">
                <ul class="mocha-menu">
                    <li><span id="toggle-passes" class="toggle-passes">show failures only</span></li>
                </ul>
                <ul class="mocha-stats">
                    <li class="passes">passes: <em>4</em></li>
                    <li class="pending">pending: <em>0</em></li>
                    <li class="failures">failures: <em>2</em></li>
                    <li class="duration">duration: <em>9.3s</em></li>
                </ul>
            </div>
            <ul id="report"><li class="suite"><h1>A.sol</h1><ul><li class="suite"><h1>A</h1><ul><li class="test pass fast"><h2>should be no error<span class="duration">1ms</span></h2><pre><code>async (done) =&#x3E; {
      if (analyzedResult[index].error) {
        let errStr = report.convertErrToStr(analyzedResult[index].error)
        if (errStr.includes(&#x27;User or default timeout reached after&#x27;) || errStr.includes(&#x27;Timeout reached after&#x27;)) {
          // if timeout, fails and shows UUID        
          done(new Error(&#x60;
  ${errStr}
Retrive the result with the above UUID later or try again.
          &#x60;))
        } else {
          done(new Error(&#x60;
MythX Error: ${errStr}
Data which was sent to MythX:
${JSON.stringify(dataArrForAPI[index], null, 2)}
&#x60;))
        }
      } else {
        done();
      }
    }</code></pre></li><li class="test pass fast"><h2>should be no MythX log<span class="duration">0ms</span></h2><pre><code>async () =&#x3E; {
      assert(!analyzedResult[index].error, &#x27;API returned Error&#x27;)
      const logs = report.getMythXLogs(analyzedResult[index].issues[0])
      assert.equal(logs.length, 0, &#x60;
Mythx Logs:
${JSON.stringify(logs, null, 2)}
Data which was sent to MythX:
${JSON.stringify(dataArrForAPI[index], null, 2)}
UUID: ${analyzedResult[index].status.uuid}&#x60;)
    }</code></pre></li><li class="test fail"><h2>should be no issue</h2><pre><code>async () =&#x3E; {
      assert(!analyzedResult[index].error, &#x27;API returned Error&#x27;)
      assert(analyzedResult[index].issues[0].issues, &#x60;issues is not set.&#x60;)
      const jsonIssues = report.getJsonIssues(analyzedResult[index].issues[0])
      assert.equal(jsonIssues.length, 0, &#x60;
=========== Vulnerability Report ================
${jsonIssues.length} vulnerabilities were found.
Vulnerabilities:
${report.getReport(jsonIssues)}
UUID: ${analyzedResult[index].status.uuid}
=================================================
&#x60;)
    }</code></pre><pre class="error">AssertionError [ERR_ASSERTION]: 

=========== Vulnerability Report ================
2 vulnerabilities were found.

Vulnerabilities:
---
  - 
    Title: &#x22;The binary addition can overflow. (High)&#x22;
    Detail: 
      swcID: &#x22;SWC-101&#x22;
      swcTitle: &#x22;Integer Overflow and Underflow&#x22;
      description: &#x22;The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.&#x22;
      locations: 
        - 
          file: &#x22;my-npm-pkg/contracts/C.sol&#x22;
          source (94:99): &#x22;a + b&#x22;
  - 
    Title: &#x22;A floating pragma is set. (Medium)&#x22;
    Detail: 
      swcID: &#x22;SWC-103&#x22;
      swcTitle: &#x22;Floating Pragma&#x22;
      description: &#x22;It is recommended to make a conscious choice on what version of Solidity is used for compilation. Currently any version equal or greater than &#x27;0.5.0&#x27; is allowed.&#x22;
      locations: 
        - 
          file: &#x22;/mnt/c/workdir/vscode_project/truffle-sca2t-test/contracts/A.sol&#x22;
          source (0:23): &#x22;pragma solidity ^0.5.0;&#x22;


UUID: e04fe5ef-7153-4005-871d-8c46963a1de2
=================================================


    at Context.it (test_security/test_A.sol_.js:84:14)</pre></li></ul></li><li class="suite"><h1>B</h1><ul><li class="test pass fast"><h2>should be no error<span class="duration">0ms</span></h2><pre><code>async (done) =&#x3E; {
      if (analyzedResult[index].error) {
        let errStr = report.convertErrToStr(analyzedResult[index].error)
        if (errStr.includes(&#x27;User or default timeout reached after&#x27;) || errStr.includes(&#x27;Timeout reached after&#x27;)) {
          // if timeout, fails and shows UUID        
          done(new Error(&#x60;
  ${errStr}
Retrive the result with the above UUID later or try again.
          &#x60;))
        } else {
          done(new Error(&#x60;
MythX Error: ${errStr}
Data which was sent to MythX:
${JSON.stringify(dataArrForAPI[index], null, 2)}
&#x60;))
        }
      } else {
        done();
      }
    }</code></pre></li><li class="test pass fast"><h2>should be no MythX log<span class="duration">0ms</span></h2><pre><code>async () =&#x3E; {
      assert(!analyzedResult[index].error, &#x27;API returned Error&#x27;)
      const logs = report.getMythXLogs(analyzedResult[index].issues[0])
      assert.equal(logs.length, 0, &#x60;
Mythx Logs:
${JSON.stringify(logs, null, 2)}
Data which was sent to MythX:
${JSON.stringify(dataArrForAPI[index], null, 2)}
UUID: ${analyzedResult[index].status.uuid}&#x60;)
    }</code></pre></li><li class="test fail"><h2>should be no issue</h2><pre><code>async () =&#x3E; {
      assert(!analyzedResult[index].error, &#x27;API returned Error&#x27;)
      assert(analyzedResult[index].issues[0].issues, &#x60;issues is not set.&#x60;)
      const jsonIssues = report.getJsonIssues(analyzedResult[index].issues[0])
      assert.equal(jsonIssues.length, 0, &#x60;
=========== Vulnerability Report ================
${jsonIssues.length} vulnerabilities were found.
Vulnerabilities:
${report.getReport(jsonIssues)}
UUID: ${analyzedResult[index].status.uuid}
=================================================
&#x60;)
    }</code></pre><pre class="error">AssertionError [ERR_ASSERTION]: 

=========== Vulnerability Report ================
1 vulnerabilities were found.

Vulnerabilities:
---
  - 
    Title: &#x22;A floating pragma is set. (Medium)&#x22;
    Detail: 
      swcID: &#x22;SWC-103&#x22;
      swcTitle: &#x22;Floating Pragma&#x22;
      description: &#x22;It is recommended to make a conscious choice on what version of Solidity is used for compilation. Currently any version equal or greater than &#x27;0.5.0&#x27; is allowed.&#x22;
      locations: 
        - 
          file: &#x22;/mnt/c/workdir/vscode_project/truffle-sca2t-test/contracts/A.sol&#x22;
          source (0:23): &#x22;pragma solidity ^0.5.0;&#x22;


UUID: 53e5108b-7505-49c8-bf87-66e4eadaab08
=================================================


    at Context.it (test_security/test_A.sol_.js:153:14)</pre></li></ul></li></ul></li></ul>
        </div>
        <script>
        function hideSuitesWithout(className) {
    var suites = document.querySelectorAll('#report > .suite');

    for (var i = 0; i < suites.length; i++) {
        let suite = suites[i];

        var els = suite.getElementsByClassName(className);
        if (!els.length) {
            suite.classList.add('hidden');
        }
    }
}

function unhide() {
    var suites = document.getElementsByClassName('suite hidden');

    while (suites.length) {
        suites[0].classList.remove('hidden');
    }
}

function togglePasses() {
    var report = document.getElementById('report');

    report.classList.toggle('hide-passes');

    if (report.classList.contains('hide-passes')) {
        hideSuitesWithout('test fail');
    } else {
        unhide();
    }
}

document.getElementById('toggle-passes').addEventListener('click', function(e) {
    e.preventDefault();
    
    this.classList.toggle('checked');

    togglePasses();
});

var tests = document.getElementsByClassName('test');

for (var i = 0; i < tests.length; i++) {
    var elem = tests[i];
    var head = elem.children[0];

    head.onclick = function () {
        var code = this.parentElement.children[1];
        var display = code.style.display;

        if (display && display === 'block') {
            code.style.display = 'none';
        } else {
            code.style.display = 'block';
        }
    };
}
        </script>
    </body>
</html>
